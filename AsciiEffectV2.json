{
  "author": "",
  "category": "Visual effect",
  "extensionNamespace": "",
  "fullName": "",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBvdW5kIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTUuNDEsMjFMNi4xMiwxN0gyLjEyTDIuNDcsMTVINi40N0w3LjUzLDlIMy41M0wzLjg4LDdINy44OEw4LjU5LDNIMTAuNTlMOS44OCw3SDE1Ljg4TDE2LjU5LDNIMTguNTlMMTcuODgsN0gyMS44OEwyMS41Myw5SDE3LjUzTDE2LjQ3LDE1SDIwLjQ3TDIwLjEyLDE3SDE2LjEyTDE1LjQxLDIxSDEzLjQxTDE0LjEyLDE3SDguMTJMNy40MSwyMUg1LjQxTTkuNTMsOUw4LjQ3LDE1SDE0LjQ3TDE1LjUzLDlIOS41M1oiIC8+PC9zdmc+",
  "name": "AsciiEffect",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/aab44d80b5a473ef190979076b22097b277f64329f91719e2b5148e57104718a_pound.svg",
  "shortDescription": "",
  "version": "0.1",
  "description": "",
  "tags": [
    "3D",
    "Post Processing",
    "Visual Effect",
    "Ascii"
  ],
  "authorIds": [
    "pxVWshl54mcV739DKIqMQ9djOQ93"
  ],
  "dependencies": [],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "AsciiEffect",
      "sentence": "Character Size: _PARAM1_, Color: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Set shader parameters",
            "const asciiCharSize = eventsFunctionContext.getArgument(\"CharSize\");",
            "const asciiColor = eventsFunctionContext.getArgument(\"Color\");",
            "// Set layer to Base layer",
            "const layer = runtimeScene.getLayer('Base layer');",
            "const renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "const scene = layer.getRenderer().getThreeScene();",
            "const camera = layer.getRenderer().getThreeCamera();",
            "const width = renderer.domElement.width;",
            "const height = renderer.domElement.height;",
            "",
            "// Get the Effect Composer",
            "const composer = layer.getRenderer().getThreeEffectComposer();",
            "if (!composer) return;",
            "",
            "// Render Pass",
            "const renderPass = new THREE_ADDONS.RenderPass(scene, camera);",
            "composer.addPass(renderPass);  // Ensure the scene renders first",
            "",
            "// ASCII Shader Code",
            "const asciiShader = {",
            "    uniforms: {",
            "        'tDiffuse': { value: null },",
            "        'resolution': { value: new THREE.Vector2(width, height) },",
            "        'charSize': { value: 8.0 }, // Adjust as needed",
            "        'color': { value: true }    // Set to false for grayscale",
            "    },",
            "    vertexShader: `",
            "        varying vec2 vUv;",
            "        void main() {",
            "            vUv = uv;",
            "            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);",
            "        }",
            "    `,",
            "    fragmentShader: `",
            "        uniform sampler2D tDiffuse;",
            "        uniform vec2 resolution;",
            "        uniform float charSize;",
            "        uniform bool color;",
            "",
            "        varying vec2 vUv;",
            "",
            "        float character(int n, vec2 p)",
            "        {",
            "            p = floor(p * vec2(-4.0, 4.0) + 2.5);",
            "            if (clamp(p.x, 0.0, 4.0) == p.x)",
            "            {",
            "                if (clamp(p.y, 0.0, 4.0) == p.y)    ",
            "                {",
            "                    int a = int(round(p.x) + 5.0 * round(p.y));",
            "                    if (((n >> a) & 1) == 1) return 1.0;",
            "                }    ",
            "            }",
            "            return 0.0;",
            "        }",
            "",
            "        void main() {",
            "            vec2 fragCoord = vUv * resolution;",
            "            vec2 pix = fragCoord.xy;",
            "            vec3 col = texture2D(tDiffuse, floor(pix / charSize) * charSize / resolution).rgb;    ",
            "            ",
            "            // Apply gamma correction to brighten the image",
            "\t\t\tfloat gray = pow(dot(col.rgb, vec3(0.299, 0.587, 0.114)), 0.5);",
            "\t\t\t",
            "\t\t\tif (gray <= 0.05) {",
            "\t\t\t\t// Output black and skip rendering the ASCII character",
            "\t\t\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "",
            "\t\t\tint n =  4096; // Start with the lightest character (space)",
            "",
            "\t\t\t// Adjusted grayscale thresholds",
            "\t\t\tif (gray > 0.1) n = 65600;   // :",
            "\t\t\tif (gray > 0.2) n = 163153;  // *",
            "\t\t\tif (gray > 0.3) n = 15255086; // o ",
            "\t\t\tif (gray > 0.4) n = 13121101; // &",
            "\t\t\tif (gray > 0.5) n = 15252014; // 8",
            "\t\t\tif (gray > 0.6) n = 13195790; // @",
            "\t\t\tif (gray > 0.7) n = 11512810; // #",
            "            ",
            "            vec2 p = mod(pix / (charSize / 2.0), 2.0) - vec2(1.0);",
            "            ",
            "            float c = character(n, p);",
            "            ",
            "            if (color) {",
            "                gl_FragColor = vec4(col * c, 1.0);",
            "            } else {",
            "                gl_FragColor = vec4(vec3(c), 1.0);",
            "            }",
            "        }",
            "    `",
            "};",
            "",
            "// Create and add the ShaderPass for the ASCII effect",
            "const asciiPass = new THREE_ADDONS.ShaderPass(asciiShader);",
            "composer.addPass(asciiPass);  // Apply the ASCII shader",
            "",
            "// Add an OutputPass to correctly output the post-processed scene",
            "const outputPass = new THREE_ADDONS.OutputPass();",
            "composer.addPass(outputPass);  // Final output",
            "",
            "//Apply parameters",
            "asciiPass.uniforms['charSize'].value = asciiCharSize; // Adjust character size as needed",
            "asciiPass.uniforms['color'].value = asciiColor;   // Set to false for grayscale",
            "",
            "// Handle Window Resize",
            "window.addEventListener('resize', function() {",
            "    const width = renderer.domElement.width;",
            "    const height = renderer.domElement.height;",
            "",
            "    composer.setSize(width, height);",
            "    asciiPass.uniforms['resolution'].value.set(width, height);",
            "});",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Example: 8",
          "name": "CharSize",
          "type": "expression"
        },
        {
          "defaultValue": "True",
          "description": "Color = True, Greyscale = False",
          "name": "Color",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}